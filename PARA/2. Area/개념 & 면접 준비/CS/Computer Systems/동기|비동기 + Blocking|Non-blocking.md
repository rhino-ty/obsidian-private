---
sticker: emoji//2b50
tags:
---
개발을 하다 보면 '동기', '비동기', 'Blocking', 'Non-blocking'이라는 용어를 자주 마주하게 됩니다. 이 개념들은 단순히 기술 면접에서 물어보는 이론적인 질문거리가 아니라, 실제로 우리가 만드는 애플리케이션의 성능과 사용자 경험에 직접적인 영향을 미치는 핵심 요소입니다.

> 웹 브라우저에서 버튼을 클릭했을 때 페이지가 멈추는 현상
> 서버가 수천 명의 사용자를 동시에 처리하지 못하는 문제
> 모바일 앱에서 데이터를 불러오는 동안 화면이 정지되는 현상

이 모든 것들은 동기/비동기와 Blocking/Non-blocking의 개념을 제대로 이해하고 적용했는지에 따라 해결 여부가 결정됩니다.

특히 JavaScript와 Node.js의 인기와 함께 비동기 프로그래밍은 선택이 아닌 필수가 되었습니다. 프론트엔드에서는 사용자 인터페이스의 반응성을 높이기 위해, 백엔드에서는 더 많은 동시 접속자를 처리하기 위해 이 개념들을 활용하고 있습니다.

이 글에서는 동기/비동기와 Blocking/Non-blocking이 정확히 무엇을 의미하는지, 어떤 차이점이 있는지, 그리고 실제 개발에서 어떻게 적용되는지를 명확하게 알아보겠습니다. 이론적인 개념을 넘어 실제 코드 예제와 함께 살펴보면서, 이 개념들이 왜 현대 소프트웨어 개발에서 이토록 중요한지 이해할 수 있을 것입니다.

복잡하게 느껴질 수 있는 이 개념들을 제대로 이해한다면, 더 효율적인 코드를 작성하고 더 나은 사용자 경험을 제공하는 애플리케이션을 개발할 수 있을 것입니다. 
# 동기/비동기와 Blocking/Non-blocking의 개념 정리

## 동기(Synchronous)와 비동기(Asynchronous)

### 동기(Synchronous)

동기는 작업의 **실행 순서**와 **완료 시점**에 관한 개념입니다.

#### 정의
한 작업이 시작되면 그 작업이 완료될 때까지 다음 작업이 기다리는 방식입니다.

#### 특성

- 코드가 순차적으로 실행
- 현재 작업이 끝나야만 다음 작업으로 넘어감
- 작업 결과를 즉시 반환
- 흐름이 예측 가능하고 직관적

#### 예시

```javascript
console.log("첫 번째");
console.log("두 번째");
console.log("세 번째");
// 항상 "첫 번째", "두 번째", "세 번째" 순서대로 출력됩니다
```

### 비동기(Asynchronous)

비동기는 작업의 완료를 기다리지 않고 다른 작업을 진행하는 방식입니다.

#### 정의
작업을 시작한 후 완료 여부와 상관없이 다음 작업을 진행하는 방식입니다.

#### 특성

- 작업이 완료되지 않아도 다음 작업 수행
- 작업 결과는 나중에 콜백, 프로미스, async/await 등으로 동기와 다르게 받음
- 여러 작업이 동시에 진행 가능
- 실행 순서가 보장되지 않을 수 있음

#### 예시

```javascript
console.log("시작");
setTimeout(() => {
  console.log("비동기 작업 완료");
}, 1000);
console.log("다음 작업 진행 중");
// "시작", "다음 작업 진행 중", "비동기 작업 완료" 순서로 출력됩니다
```

## Blocking과 Non-blocking

### Blocking

Blocking은 제어권(control)에 관한 개념으로, 호출한 함수가 제어권을 돌려받지 못하는 상태를 말합니다.

#### 정의
특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태입니다.

#### 특성

- 호출한 함수는 호출된 함수가 작업을 완료할 때까지 대기
- 해당 스레드는 다른 작업을 수행 불가능
- 리소스를 효율적으로 사용하지 못할 수 있음
- 주로 동기 방식과 함께 사용 (항상 그런 것은 아님)

#### 예시

```javascript
// Blocking I/O 예시 (Node.js)
const fs = require('fs');
const data = fs.readFileSync('file.txt', 'utf8'); // 이 줄에서 블로킹됨
console.log(data);
console.log('다음 작업'); // 파일 읽기가 완료된 후에만 실행됨
```

### Non-blocking

Non-blocking은 호출한 함수가 즉시 제어권을 돌려받는 상태를 말합니다.

#### 정의
작업 완료 여부와 상관없이 프로그램의 제어권을 즉시 반환하는 상태입니다.

#### 특성

- 호출한 함수는 작업 시작 후 즉시 제어권 회수
- 다른 작업을 계속 수행 가능
- 리소스를 효율적으로 사용 가능
- 주로 비동기 방식과 함께 사용 (항상 그런 건 아님)

#### 예시

```javascript
// Non-blocking I/O 예시 (Node.js)
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data); // 파일 읽기가 완료된 후에 실행
});
console.log('다음 작업'); // 파일 읽기를 기다리지 않고 즉시 실행
```

## 이 개념들의 관계

동기/비동기와 Blocking/Non-blocking은 서로 다른 개념이지만 자주 혼동됩니다.

1. **동기-Blocking**: 가장 일반적인 조합. 작업이 완료될 때까지 기다리며 다른 작업을 할 수 없습니다.
    - 예: `fs.readFileSync()`
2. **비동기-Non-blocking**: 작업을 시작하고 제어권을 돌려받아 다른 작업을 계속 진행합니다.
    - 예: `fs.readFile()` 콜백 방식
3. **동기-Non-blocking**: 작업의 완료를 주기적으로 확인(polling)하는 방식입니다.
    - 예: 완료 여부를 계속 체크하는 루프
4. **비동기-Blocking**: 드문 조합이지만, 비동기 작업을 시작하고 다른 스레드에서 블로킹될 수 있습니다.
    - 예: 멀티스레드 환경에서 한 스레드가 블로킹되지만 다른 스레드는 계속 실행

이러한 개념들을 이해하면 효율적인 프로그램을 설계하고 적절한 상황에서 각 패턴을 활용할 수 있습니다.