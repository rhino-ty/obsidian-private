---
sticker: emoji//2b50
---
함수와 함수가 선언된 어휘적 환경의 조합입니다. 내부 함수가 외부 함수의 변수에 접근할 수 있는 것을 의미합니다.

[같이 보면서 공부하면 좋은 유튜브](https://youtu.be/DjpG-uz-gMc?si=mln2mgltw_IFw6D0)
#### 어휘적 환경이 뭐죠?

> 함수가 선언된 주변 환경을 의미합니다. 주로 외부 함수(outer function)의 변수가 내부 함수(inner function)의 어휘적 환경에 포함됩니다. 그래서 내부 함수가 리턴되어도 나중에 클로저의 어휘적 환경에 접근하여 외부 함수의 변수에 접근할 수 있습니다.

#### 그래서 클로저를 언제 쓰나요?

> 클로저는 사실 자바스크립트의 어떤 함수든 가지고 있습니다. 어떤 함수든 전역 변수에 접근할 수 있기 때문입니다. 그래서 언제나 쓰이고 있습니다. 자바스크립트에서 private 메서드를 구현하기 위해서도 클로저를 활용할 수 있습니다. 클로저 내에 있는 변수는 외부에서 접근할 수 없기 때문에, 클로져 내에 있는 변수를 활용 할 수 있는 private 메서드만 따로 노출시켜서 인터페이스처럼 사용할 수 있게 됩니다.

- 예시 1 : 리액트에서 상태 관리하기

```jsx
import React, { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
};
```

위 코드에서 **`useState`**는 상태 관리를 위한 Hook입니다. 이 Hook을 사용하여 **`count`** 상태와 **`setCount`** 함수를 선언합니다. **`handleIncrement`** 함수는 **`count`** 상태를 변경하는 역할을 합니다.

이때, **`handleIncrement`** 함수는 **`useState`** 함수 내부에서 선언된 **`count`** 상태에 접근합니다. **`useState`** 함수는 클로저를 활용하여 **`count`** 상태를 **`handleIncrement`** 함수 내에서 계속해서 사용할 수 있도록 합니다.

- 예시 2 : 바닐라 JS

```jsx
function createCounter() {
  let count = 0;
  return function () {
    debugger;
    count += 1;
    return count;
  };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

#### 클로저 사용해 useState 구현해보기

클로저를 사용해 React의 `useState`를 구현한다면 다음과 같이 접근할 수 있습니다:

```javascript
function createUseState(initialValue) {
  let state = initialValue; // 클로저를 통해 유지될 상태값
  
  function setState(newValue) {
    state = newValue;
    // 실제 React에서는 여기서 컴포넌트 리렌더링을 트리거
    render();
  }
  
  // 상태값과 상태 변경 함수를 배열로 반환
  return [state, setState];
}

// 사용 예시
function Counter() {
  const [count, setCount] = createUseState(0);
  
  return {
    increment: () => setCount(count + 1),
    getCount: () => count
  };
}
```

1. 클로저를 통한 상태 유지
   - `createUseState` 함수 내부의 `state` 변수는 클로저를 통해 유지됨
   - `setState` 함수가 이 `state` 변수에 계속 접근 가능

2. 실제 React와의 차이점
   - 실제 React의 `useState`는 훨씬 복잡한 구현을 가짐
   - 컴포넌트별 상태 관리, 리렌더링 처리 등이 추가로 필요

3. 한계점
   - 이 단순 구현은 컴포넌트 리렌더링을 직접 처리하지 않음
   - 여러 상태값 관리나 동시성 처리 등이 고려되지 않음

단, 이것은 매우 단순화된 구현이며, 실제 React의 `useState`는 Fiber 아키텍처, 리렌더링 큐, 배치 업데이트 등 훨씬 복잡한 메커니즘을 포함합니다.

---

## 예시: 아이스크림
클로저는 '기억력이 좋은 함수'라고 생각해보세요.

상상해보세요. 당신이 아이스크림 가게에서 일하고 있습니다. 당신의 임무는 손님이 주문한 아이스크림을 만드는 것입니다.

1. 아이스크림 기계 (외부 함수): 당신은 아이스크림 기계 앞에 서 있습니다. 이 기계는 다양한 맛의 아이스크림을 만들 수 있습니다.
2. 레시피 (내부 함수): 손님이 주문할 때마다, 당신은 특정 맛의 아이스크림을 만드는 '레시피'를 받습니다.
3. 재료 (외부 변수): 아이스크림 기계 옆에는 다양한 재료들이 있습니다 (우유, 설탕, 초콜릿 등).

이제 클로저의 마법이 시작됩니다:

1. 기억력 좋은 레시피 (클로저): 당신이 만든 특별한 레시피는 아주 똑똑해서, 아이스크림 기계 근처의 재료들을 '기억'합니다. 심지어 당신이 다른 일을 하러 가도, 이 레시피는 여전히 필요한 재료들을 기억하고 있습니다.
2. 레시피의 독립성 (스코프와의 관계): 이 레시피는 다른 가게에 가져가도 작동합니다. 왜냐하면 필요한 재료 정보를 자체적으로 기억하고 있기 때문입니다. 이것이 바로 클로저가 자신의 '렉시컬 스코프'를 기억하는 방식입니다.

![[Pasted image 20250227102354.png]]

실제 코드로 보면:

```jsx
function 아이스크림기계(맛) {  // 외부 함수
  let 우유 = "신선한 우유";  // 외부 변수

  function 레시피() {  // 내부 함수 (클로저)
    console.log(`${우유}로 만든 ${맛} 아이스크림`);
  }

  return 레시피;
}

let 초코아이스크림 = 아이스크림기계("초코");
초코아이스크림();  // "신선한 우유로 만든 초코 아이스크림" 출력

```

여기서 `초코아이스크림` 함수는 '기억력이 좋은 레시피'입니다. 이 함수는 `아이스크림기계` 함수가 이미 실행을 마쳤음에도 불구하고, 여전히 `우유` 변수를 기억하고 있습니다.

클로저의 이런 특성 덕분에, 함수가 자신이 생성된 환경(스코프)의 변수들을 계속 기억하고 접근할 수 있게 됩니다. 이는 마치 레시피가 아이스크림 가게를 떠나도 필요한 재료 정보를 모두 기억하고 있는 것과 같습니다.

---

## 의의

클로저를 사용하는 주요 이유는 데이터 보존, 정보 은닉, 비동기 작업 및 이벤트 처리, 콜백 함수 전달 등을 가능하게 하여 유연하고 강력한 프로그래밍 패턴을 구현할 수 있다는 점입니다.

1. **데이터 은닉과 보존을 통해 변수 보호 및 지속성 유지** 
   클로저는 함수와 그 함수가 참조하는 외부 변수들을 함께 저장하여, 함수가 종료된 이후에도 이전 상태를 유지하고 업데이트할 수 있습니다. 이를 통해 데이터의 지속성과 상태 유지를 가능하게 합니다.
2. **상태 유지를 통한 이전 상태 유지 및 업데이트** 
   클로저는 외부 변수를 함수 내부에서만 접근할 수 있도록 제한함으로써 정보 은닉과 보호를 구현할 수 있습니다. 외부에서 직접적으로 변수에 접근할 수 없으므로, 변수의 무결성을 유지하고 오용을 방지할 수 있습니다.
3. **비동기 작업 및 이벤트 처리에 활용 가능** 
   클로저는 비동기 작업이나 이벤트 핸들링에 유용합니다. 비동기 작업이 완료될 때까지 클로저가 외부 변수를 참조하고 조작할 수 있으므로, 작업의 상태를 유지하고 필요한 작업을 수행할 수 있습니다.
4. **외부 변수에 접근하여 자유롭게 사용할 수 있음** 
   클로저를 사용하면 함수 내부에서 정의된 함수를 외부로 전달할 수 있습니다. 이는 콜백 함수로 활용되어 특정 이벤트가 발생했을 때 원하는 동작을 수행할 수 있도록 합니다.

클로저는 외부 변수에 대한 참조를 유지하므로, 이 변수들이 가비지 컬렉션되지 않습니다. 즉, 불필요하게 많은 클로저를 사용하면 메모리 누수가 발생할 수 있습니다.