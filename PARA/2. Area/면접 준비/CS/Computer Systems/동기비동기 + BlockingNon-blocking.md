---
sticker: emoji//2b50
tags:
---
# 동기/비동기와 Blocking/Non-blocking의 개념 정리

## 동기(Synchronous)와 비동기(Asynchronous)

### 동기(Synchronous)

동기는 작업의 **실행 순서**와 **완료 시점**에 관한 개념입니다.

**정의**: 한 작업이 시작되면 그 작업이 완료될 때까지 다음 작업이 기다리는 방식입니다.

**특성**:

- 코드가 순차적으로 실행됩니다
- 현재 작업이 끝나야만 다음 작업으로 넘어갑니다
- 작업 결과를 즉시 반환받습니다
- 흐름이 예측 가능하고 직관적입니다

**예시**:

```javascript
console.log("첫 번째");
console.log("두 번째");
console.log("세 번째");
// 항상 "첫 번째", "두 번째", "세 번째" 순서대로 출력됩니다
```

### 비동기(Asynchronous)

비동기는 작업의 완료를 기다리지 않고 다른 작업을 진행하는 방식입니다.

**정의**: 작업을 시작한 후 완료 여부와 상관없이 다음 작업을 진행하는 방식입니다.

**특성**:

- 작업이 완료되지 않아도 다음 작업을 수행합니다
- 작업 결과는 나중에 콜백, 프로미스, async/await 등으로 받습니다
- 여러 작업이 동시에 진행될 수 있습니다
- 실행 순서가 보장되지 않을 수 있습니다

**예시**:

```javascript
console.log("시작");
setTimeout(() => {
  console.log("비동기 작업 완료");
}, 1000);
console.log("다음 작업 진행 중");
// "시작", "다음 작업 진행 중", "비동기 작업 완료" 순서로 출력됩니다
```

## Blocking과 Non-blocking

### Blocking

Blocking은 제어권(control)에 관한 개념으로, 호출한 함수가 제어권을 돌려받지 못하는 상태를 말합니다.

**정의**: 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태입니다.

**특성**:

- 호출한 함수는 호출된 함수가 작업을 완료할 때까지 대기합니다
- 해당 스레드는 다른 작업을 수행할 수 없습니다
- 리소스를 효율적으로 사용하지 못할 수 있습니다
- 주로 동기 방식과 함께 사용됩니다 (항상 그런 것은 아님)

**예시**:

```javascript
// Blocking I/O 예시 (Node.js)
const fs = require('fs');
const data = fs.readFileSync('file.txt', 'utf8'); // 이 줄에서 블로킹됨
console.log(data);
console.log('다음 작업'); // 파일 읽기가 완료된 후에만 실행됨
```

### Non-blocking

Non-blocking은 호출한 함수가 즉시 제어권을 돌려받는 상태를 말합니다.

**정의**: 작업 완료 여부와 상관없이 프로그램의 제어권을 즉시 반환하는 상태입니다.

**특성**:

- 호출한 함수는 작업 시작 후 즉시 제어권을 돌려받습니다
- 다른 작업을 계속 수행할 수 있습니다
- 리소스를 효율적으로 사용할 수 있습니다
- 주로 비동기 방식과 함께 사용됩니다 (항상 그런 것은 아님)

**예시**:

```javascript
// Non-blocking I/O 예시 (Node.js)
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data); // 파일 읽기가 완료된 후에 실행
});
console.log('다음 작업'); // 파일 읽기를 기다리지 않고 즉시 실행
```

## 이 개념들의 관계

동기/비동기와 blocking/non-blocking은 서로 다른 개념이지만 자주 혼동됩니다:

1. **동기-Blocking**: 가장 일반적인 조합. 작업이 완료될 때까지 기다리며 다른 작업을 할 수 없습니다.
    
    - 예: `fs.readFileSync()`
2. **비동기-Non-blocking**: 작업을 시작하고 제어권을 돌려받아 다른 작업을 계속 진행합니다.
    
    - 예: `fs.readFile()` 콜백 방식
3. **동기-Non-blocking**: 작업의 완료를 주기적으로 확인(polling)하는 방식입니다.
    
    - 예: 완료 여부를 계속 체크하는 루프
4. **비동기-Blocking**: 드문 조합이지만, 비동기 작업을 시작하고 다른 스레드에서 블로킹될 수 있습니다.
    
    - 예: 멀티스레드 환경에서 한 스레드가 블로킹되지만 다른 스레드는 계속 실행

이러한 개념들을 이해하면 효율적인 프로그램을 설계하고 적절한 상황에서 각 패턴을 활용할 수 있습니다.