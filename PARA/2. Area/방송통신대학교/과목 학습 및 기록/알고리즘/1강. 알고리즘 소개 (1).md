---
sticker: emoji//1f47d
tags:
  - algorithm
---
**[학습 자료](https://ucampus.knou.ac.kr/ekp/user/lectureData/retrieveUCRLectureData.do)**
# 학습개요

알고리즘의 첫 번째 강의 시간으로서 알고리즘 전반에 걸친 기본적인 개념을 소개한다. 우선 알고리즘의 필요성과 정의를 간단히 살펴본 후, 알고리즘의 대표적인 설계 기법들에 대해서 중점적으로 학습한다.

# 학습목표

1. 알고리즘의 중요성과 개념을 이해할 수 있다.
2. 대표적인 알고리즘 설계 기법들의 종류와 개념을 이해할 수 있다.
3. 거스름돈 문제와 배낭 문제의 개념, 동작 원리 및 특성을 이해할 수 있다.

# 주요용어

1. **알고리즘(algorithm)** : 주어진 문제에 대해 하나 이상의 결과를 생성하기 위해 모호하지 않고 단순 명확하며 컴퓨터가 수행할 수 있는 유한개의 일련의 명령을 순서에 따라 구성한 것
2. **욕심쟁이 방법(greedy method)** : 해를 구하는 일련의 선택 과정마다 해당 단계에서 '가장 최선'이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적인 전략을 취하는 방법
3. **거스름돈 문제(coin change problem)** : 가게에게 고객에게 돌려줄 거스름돈이 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제
4. **배낭 문제(knapsack problem)** : 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어있는 물체의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법을 찾아내는 문제
    - **0/1 배낭 문제** : 배낭에 넣는 물체를 쪼갤 수 없다는 가정이 있는 배낭 문제로서, 이 경우에는 욕심쟁이 방법으로 해결할 수 없는 NP-완전문제가 된다.
5. **분할정복 방법(divide-and-conquer method)** : 순환적으로 문제를 푸는 하향식 접근 방식으로, 주어진 문제의 입력을 더 이상 쪼갤 수 없을 때까지 2개 이상의 작은 문제로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 방법
6. **동적 프로그래밍 방법(dynamic programming method)** : 주어진 문제의 입력의 크기가 가장 작은 부분 문제부터 해를 구하여 저장해 놓고 이를 이용하여 입력 크기가 보다 큰 원래의 문제를 점진적으로 해결하는 상향식 접근 방법

# 알고리즘의 정의

<img width="517" alt="image" src="https://github.com/user-attachments/assets/49b57573-5b1b-42ae-be8f-928e78eb54b5" />

- 주어진 문제를 해결하거나 함수를 계산하기 위해 따라야 할 명령어들을 단계적으로 나열한 것
- 알고리즘이 만족해야 할 조건
    - **입출력** : 외부에서 제공되는 0개 이상의 입력과 1개 이상의 출력이 있어야 함
    - **명확성** : 각 명령은 모호하지 않고 단순 명확해야 함
    - **유한성** : 한정된 수의 단계 후에 반드시 종료되어야 함
    - **유효성** : 모든 명령은 실행 가능해야 함
    - **효율성**  : 실용적 관점에서 알고리즘의 성능이 중요함

# 알고리즘 설계 기법

## 알고리즘 생성 과정

1. **설계** : 문제 해결을 위한 전략 개발
	- 욕심쟁이 방법, 분할정복 방법, 동적 프로그래밍 방법 등 알고리즘 설계
2. **표현(기술)** : 알고리즘을 명확하게 표현
	- 의사코드, 플로우차트(순서도), 프로그래밍 언어 등
3. **정확성 분석** : 알고리즘이 올바른 결과를 도출하는지 확인
4. **효율성 분석** : 알고리즘의 성능 평가
	- 시간 복잡도, 공간 복잡도 등

## 대표적인 알고리즘 설계 방법

1. 욕심쟁이 방법 (Greedy Method)
2. 분할정복 방법 (Divide-and-Conquer Method)
3. 동적 프로그래밍 방법 (Dynamic Programming Method)

### 1. 욕심쟁이 방법 (Greedy Method)

- **개념**
	- 해를 구하는 일련의 선택 단계마다 **전후 단계의 선택과는 무관**하게 해당 단계에서 가장 최선이라고 볼 수 있는 **국부적인 최적해**를 선택해 나가는 방법
- **특징**
	- **이전 선택을 번복**하지 않고 **항상 현재 상황에서 최선의 선택**을 함
- **한계**
	- 국부적인 최적해가 **항상** 전체적인 최적해를 구성하지 못하는 경우도 있음

#### 적용 사례

1. **거스름돈 문제 (Coin Change Problem)**
    - 가게에서 고객에게 돌려줄 **거스름돈**을 **최소 개수의 동전**으로 제공하는 문제
    - 동전의 액면가가 {500원, 100원, 50원, 10원, 1원}인 경우 욕심쟁이 방법 적용 가능
        - 최대한 큰 동전부터 자례대로 넣으면 됨
    - 동전의 액면가가 일반적인 경우(100원이 아닌 120원)에는 욕심쟁이 방법 적용 불가
2. **배낭 문제 (Knapsack Problem)**
    - 배낭의 용량을 초과하지 않는 범위에서 가치의 합이 최대가 되도록 물건을 선택하는 문제
    - 분할 가능한 배낭 문제: 물건을 부분적으로 선택할 수 있는 경우 욕심쟁이 방법 적용 가능
        - **단위 무게당 이익이 가장 큰 물체**부터 최대한 넣는 과정을 밟으면 됨
    - **0/1 배낭 문제** : **물건을 쪼개서 넣을 수 없는 경우** 욕심쟁이 방법 적용 불가
        - 추가) 백준 12865 평범한 배낭이 이에 해당
3. **그 외 적용 알고리즘**
    - 최소 신장 트리 (크루스칼 알고리즘, 프림 알고리즘)
    - 단일 출발점 최단 경로 (데이크스트라 알고리즘)


### 2. 분할정복 방법 (Divide-and-Conquer Method)

- **개념**
	- 주어진 문제의 입력을 더 이상 **나눌 수 없을 때까지 2개 이상의 작은 문제들로 분할**하고, 각각 **해결한 후 결합**하는 방법
- **특징**
	- **하향식(top-down)** 접근 방식으로, 분할된 문제는 **원래 문제와 동일한 형태**이며 서로 **독립적**
- **단계**
    1. **분할(Divide)**: 주어진 문제의 입력을 **여러 개의 작은 문제로 분할**
    2. **정복(Conquer)**: 작은 문제들을 순환적으로 **분할**하고, 작은 문제가 더 이상 **분할되지 않을 정도**로 크기가 충분히 작으면 **순환 호출 없이 작은 문제에 대한 해**를 구함
    3. **결합(Combine)**: 작은 문제에 대해 **정복된 해**를 **결합**하여 원래 문제의 해를 구함

#### 적용 사례

1. 이진 탐색 (Binary Search)
2. 퀵 정렬 (Quick Sort)
3. 합병 정렬 (Merge Sort)

#### 이진 탐색 알고리즘과 분할정복 방법의 관계

- **분할**: 배열의 가운데 원소를 기준으로 왼쪽과 오른쪽 부분배열로 절반씩 분할
- **정복**: 탐색 키가 가운데 원소보다 작으면 왼쪽 부분배열을 대상으로 이진 탐색을 순환 호출, 크면 오른쪽 부분배열을 대상으로 이진 탐색을 순환 호출
- **결합**: 탐색 키와 가운데 원소가 같으면 해당 원소의 배열 인덱스를 반환/종료하고, 부분배열에 대한 탐색 결과가 직접 반환되므로 별도의 결합 과정이 불필요

### 3. 동적 프로그래밍 방법 (Dynamic Programming Method)

- **개념**
	- 입력 크기가 작은 부분 문제부터 해를 구해 **테이블에 저장**해 놓고 이를 이용해 **더 큰 문제를 해결**하는 방법
- **특징**
	- **상향식(bottom-up)** 접근 방식으로, 중복 계산을 피하기 위해 부분 문제의 해를 **메모이제이션**(memoization)함
		- 각각의 작은 문제는 원래 문제와 동일, 입력의 크기만 작음
		- 작은 문제들은 서로 독립일 필요가 없음
- **조건**:
    1. 최적 부분 구조(Optimal Substructure): 큰 문제의 최적해가 작은 문제의 최적해를 포함
    2. 중복 부분 문제(Overlapping Subproblems): 동일한 부분 문제가 여러 번 등장

#### 적용 사례

1. 모든 정점 쌍 간의 최단 경로 (플로이드 알고리즘)
2. 행렬의 연쇄적 곱셈 문제
3. 최장 공통 부분 수열 문제


# 정리하기

## 1. 기본 개념

- 알고리즘 → 주어진 문제를 해결하거나 함수를 계산하기 위해 따라야 할 명령어들을 단계적으로 나열한 것
- 만족해야 할 조건 → (입출력, 명확성, 유한성, 유효성) + (실용적 관점에서는 '효율성'도 중요)

## 2. 알고리즘 설계

- 알고리즘 생성 과정: 설계 → 표현(기술) → 정확성 분석 → 효율성 분석
- 많은 부류의 문제에 적용될 수 있는 대표적인 설계 방법 → 욕심쟁이 방법, 분할정복 방법, 동적 프로그래밍 방법

### 욕심쟁이 방법

- 해를 구하는 일련의 선택 단계마다 전후 단계의 선택과는 무관하게 해당 단계에서 가장 최선이라고 볼 수 있는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 구할 수 있을 것이라는 희망적인 전략을 취하는 방법
- 한계 → 국부적인 최적해가 항상 전체적인 최적해를 구성하지 못하는 경우도 있음
- 적용 알고리즘/문제 → 거스름돈 문제, 배낭 문제, 최소 신장 트리(크루스칼 알고리즘, 프림 알고리즘), 단일 출발점 최단 경로(데이크스트라 알고리즘)
    - 거스름돈 문제 → 가게에서 고객에게 돌려줄 거스름돈이 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제 → 동전의 액면가가 일반적인 경우에는 욕심쟁이 방법 적용 불가
    - 배낭 문제 → 배낭의 용량을 초과하지 않는 범위 내에서 배낭에 들어 있는 물체들의 이익의 합이 최대가 되도록 물체를 넣는 방법을 찾는 문제 → 물체를 쪼개서 넣을 수 없는 '0/1 배낭 문제'는 욕심쟁이 방법 적용 불가

### 분할정복 방법

- 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 2개 이상의 작은 문제들로 순환적으로 분할하고, 이렇게 분할된 작은 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방식
- 분할된 문제는 입력 크기만 작아졌을 뿐 원래 문제와 동일하며 서로 독립적
- '분할'-'정복'-'결합'의 단계로 구성
- 적용 알고리즘/문제 → 이진 탐색, 퀵 정렬, 합병 정렬

### 동적 프로그래밍 방법

- 입력의 크기가 가장 작은 부분 문제부터 해를 구하여 저장해 놓고 이를 이용해서 입력 크기가 보다 큰 문제의 해를 점진적으로 만들어 가는 상향식 접근 방법
- 분할된 문제는 입력 크기만 작아졌을 뿐 원래 문제와 동일하며 서로 독립적일 필요는 없음
- 적용 알고리즘/문제 → 모든 정점 쌍 간의 최단 경로를 구하는 플로이드 알고리즘, 교재 5장(행렬의 연쇄적 곱셈 문제, 최장 공통 부분 수열 문제)