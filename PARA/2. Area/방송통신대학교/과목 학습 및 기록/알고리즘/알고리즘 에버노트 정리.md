![Creative Commons License](https://public.www.evernote.com/resources/s248/bdcff460-4fbb-46c4-bd95-bf95229a8c6c)

[알고리즘 에버노트 정리 글](https://lite.evernote.com/note/0c3d44e1-c864-4517-ac64-735b10f2f666)을 옮겼습니다.

[http://bit.ly/algOrithm](http://bit.ly/algOrithm) by [Unsok Lee](mailto:hayeoiroo@gmail.com)
초판 4쇄 (2015.1.25)

---

# I. 알고리즘 소개

1. 자료구조(data structure)
   - 컴퓨터 기억공간 내에 자료를 표현하고 조직화시키는 방법

![Data Structure](https://public.www.evernote.com/resources/s248/6b669a68-6128-42a7-b1f3-5cd1adc71f71)

1. 배열(array)
   - 같은 자료형을 갖는 연속적인 데이터를 하나의 변수로 묶어놓은 데이터 집합
   - 논리적 순서와 물리적 순서가 동일 : 각 원소에 대한 접근시간은 동일
   - 인덱스(index, 첨자)로 각 원소를 구분
   - 1차원 / 다차원 배열 [행(row)][열(column)]
   - 희소배열(sparse matrix) : 원소값이 0인 원소들이 많은 배열, ‘행,열,값’으로 효율적으로 표현 가능
   - 데이터의 삽입/삭제 연산에서 시간적 오버헤드 발생, 적절한 배열 크기를 미리 결정하기 어려워 오버플로/공간의 낭비를 초래

2. 리스트
    1) 선형리스트(linear list, ordered list)
         - 1개 이상의 원소들이 순서를 가지고 구성되어 있는것
              A = (a<sub>1</sub>, a<sub>2</sub>, …, a<sub>n</sub>)
         - 1차원 배열과 동일한 구조로 빈번한 자료이동에 불편
    2) 연결리스트(linked list)
         a. 데이터필드와 링크필드를 가진 노드들의 연결을 통해 구성하여, 각 원소들이 물리적으로 인접해있지 않아도 됨
         b. 링크필드만 조정하는 작업을 통해 간단히 삽입과 삭제를 수행, 기억장치의 할당과 반환을 통해 동적으로 관리

![Linked List](https://public.www.evernote.com/resources/s248/60e50382-0a17-44bf-b256-78abd785826a)

         c. 포인터 변수 head : 연결리스트의 시작노드
              노드의 링크 : 바로 다음에 위치하는 노드를 가리키는 주소
              마지막 노드의 링크 : NULL 포인터
         d. 종류 :
              - 단일연결리스트(singly linked list)
              - 이중연결리스트(doubly linked list)
              - 원형연결리스트(circular linked list) : 순회연산 가능

1.  **<u>스택(stack)</u>**
   - 데이터의 삽입과 삭제가 리스트의 한쪽 끝에서만 이루어지는 제한된 선형 리스트
   - 후입선출(LIFO, Last-in First-Out) 구조
   - 서브루틴호출, 재귀, 수식계산, 인터럽트 _서브루틴을 부르는 것은 재 수 더럽게 없는 것 !_

![Stack](https://public.www.evernote.com/resources/s248/ee73959d-e104-42a5-b93d-ee2c41da5e1c)

1.  **<u>큐(queue)</u>**
    1) 큐
         - 한쪽 끝에서는 삽입만 수행하고, 다른 쪽 끝에서는 삭제만 수행하는 리스트
         - 선입선출(FIFO, First-In First-Out), enqueue, dequeue

![Queue](https://public.www.evernote.com/resources/s248/2f17727c-1fe8-4d48-bcb3-386797e806ee)

         - 오버플로(overflow), 언더플로(underflow) 발생
         - 작업스케줄링, 버퍼
    1) 원형큐(circular queue) : front 앞에 빈자리가 존재하게되는 순차적인 큐의 단점을 보완, 모듈(module) 연산자
    2) 데크(deque, double ended queue) : 양쪽 끝 모두에서 삽입과 삭제가 가능한 구조

1. 트리(tree)
   - 노드(node, 정보항목)와 가지(branch, 노드를 연결)로 계층적인 구조를 이루는 비선형 자료구조
    1) 트리구조

![Tree Structure](https://public.www.evernote.com/resources/s248/1464412e-72ae-428b-a62c-80aa55e6e1cf)

    1) **이진트리(binary tree)**
         - 공백이거나 각 노드의 차수가 2이하인 순서트리 (not 공백트리)
         - 한 노드에 대한 서브트리의 순서는 중요한 의미를 갖는다
         a. 특성
              - *n*개의 노드를 갖는 경우 :
                   트리 최대높이 = (경사이진트리) *n*
                   트리 최소높이 = (포화, 완전이진트리) *| log<sub>2</sub>n | + 1*
              - 각 레벨 *i* 에서 가질 수 있는 최대 노드수 = **2<sup>i</sup>** (*i* ≧ 0 )
              - 깊이(높이) *k ( k ≧ 1 )*인 이진트리의 최대 노드수 = **2<sup>k</sup> - 1**
         b. 이진트리의 균형
              - 트리의 높이가 짧을수록 탐색이 짧음
              - 균형요소(balance factor) : 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이 차
              - AVL(Adelson, Velskii, Landis) 트리 : 균형요소가 -1, 0, 1 균형을 이루고 있는 트리
         c. **이진트리의 종류**
              - **<u>전(full) 이진트리</u>** : 모든 노드의 차수가 0이거나 2인 이진트리
                   단말 노드의 수 = 비단말 노드의 수 + 1
               - **<u>포화(perfect) 이진트리</u>** : 빈자리없이 노드를 모두 가져 높이가 동일한 이진트리
                   노드의 개수 = *2<sup>k</sup> - 1* (*k* : 높이)
                   단말 노드의 개수 = *2<sup>k-1</sup>*
              - **<u>완전(complete) 이진트리</u>** :
                   마지막 레벨 전까지 포화이진트리를 형성하고, 마지막 레벨에서는 왼쪽부터 오른쪽으로 중간에 빈자리 없이 채워진 트리
                   총 노드수가 *2<sup>k-1</sup>-1*을 초과하지 않으면서 포화이진트리의 노드번호에 해당하는 연속적인 번호를 갖는다
                   노드의 개수 = *2<sup>k-1</sup>* 에서 *2<sup>k</sup> - 1* 사이의 값
              - **<u>균형(balanced) 이진트리</u>** : 모든 단말노드의 깊이 차이가 많아야 1인 이진트리
                   균형 이진트리의 깊이 ⎣*log<sub>2</sub>n*⎦ (*n* : 노드의 개수)
              - **<u>경사(skewed) 이진트리</u>** : 한쪽 방향으로만 뻗어나간 트리, 낭비가 심함

![Binary Tree Types](https://public.www.evernote.com/resources/s248/b52815a1-65c5-4a78-a3e7-89a410b74956)

         d. 연산
              - 삽입
              - 삭제
              - 순회(traverse) : 일정한 순서에 따라 트리의 각 노드를 한번씩 방문 (각 레벨마다 자식노드가 있을경우, 내려가 순서를 다시 고려)

![Tree Traversal](https://public.www.evernote.com/resources/s248/64c60b18-ce05-4ba5-989a-6bc87de30f30)

         e. 표현
              - 이진트리는 일차원 배열 또는 연결리스트를 이용해서 구현
    1) **히프(heap)트리**
         - 각 노드의 값이 그 노드의 자식노드의 값보다 크거나(작거나) 같은 완전이진트리
         - 최대값 삭제 및 원소 삽입이 수월해서 우선순위 큐, 히프정렬에서 이용

![Heap Tree](https://public.www.evernote.com/resources/s248/36cd3da3-b5d3-4760-8758-779c1a0da0ef)

    1) 이진탐색트리(binary search tree)
         - 각 노드의 유일한 키값을 가지며, 각 노드의 왼쪽 서브트리의 모든 키값은 해당노드의 키값보다 작고,
           오른쪽 서브트리의 모든 키값은 해당노드의 키값보다 크다
         - 루트 노드로 부터 키값 비교를 통해 작으면 왼쪽가지, 크면 오른쪽가지를 따라 탐색

1. 그래프
    1) 기본 개념
         - G = ( V, E ) : 그래프G는 정점(vertex)들의 유한집합V와 정점들의 쌍을 연결하는 간선(edge)들의 유한집합E로 구성
         - 일반적으로 정점은 인덱스를, 간선은 가중치(weight)를 갖는다
         - 간선의 방향성 존재 여부에 따라

![Graph Types](https://public.www.evernote.com/resources/s248/e82202a3-0449-4879-b833-9251820f38d6)

    1) 용어
         - 인접과 부수 : 두 정점은 인접(adjacent)해 있다.
                                  해당 간선은 두 정점에 부속(incident) 되었다
         - 경로(path) : 간선으로 연결된 정점들의 순차열 (예) G<sub>2</sub>의 {3,4,2}
         - 경로의 길이(length) : 경로에 포함된 간선의 개수
         - 단순경로(simple path) : 한 경로상에서 처음과 마지막 정점을 제외한 모든 정점들이 모두 다른 경로
         - 사이클(cycle) : 세개 이상의 정점을 가진 경로중에서 시작정점과 끝정점이 같은 경로 (예) G<sub>2</sub>에서 {1,3,4,1}
         - 단순사이클 : 시작정점과 끝정점을 제외하고 모든 정점이 서로 다른 사이클
         - 연결되다(connected) : 두 정점 사이에 경로가 존재하는 경우
         - 서로 연결되었다
         - 강하게(strongly, 양쪽으로), 약하게(weakly, 한쪽으로만) 연결되었다
         - 가중 그래프(weighted graph) : 간선에 비용이나 시간과 같은 특정의미(숫자)를 부여한 그래프 (예) 도시와 도시 사이의 거리
         - 부분 그래프(subgraph) : G=(V,E) 에 대해서 V'(G)≦V(G)이고 E'(G)≦E(G)인 그래프 G'=(V’,E')
         - 완전 그래프(complete) : 최대개수의 간선을 갖는 그래프, 무방향 *n(n-1)/2*, 방향 *n(n-1)*
         - 차수(degree) : 정점에 부수된 간선의 개수, 진입차수(in-degree), 진출차수(out-degree)

1. 알고리즘(algorithm)
     a. 주어진 문제에 대한 결과를 생성하기 위해, 단순하며 모호하지 않고 컴퓨터가 수행 가능한 일련의 유한개의 명령들을 순서적으로 구성한 것
     b. **알고리즘의 만족조건**
          - **입출력** : (외부에서 입력을 받아들여), 출력을 생성
          - **명확성** : 각 단계는 단순하고 모호하지 않아야
          - **유한성** : 반드시 종료해야
          - **유효성** : 모든 명령이 수행가능해야
          - **효율성**
     c. 알고리즘 생성
         - 설계 : 상향/하향식
         - 표현 : 일상언어, 순서도, 의사코드, 프로그래밍 코드
         - 검증 : 수학적/실용적
         - 분석 : 공간/시간 복잡도

9.  **<u>알고리즘 설계</u>**
    - 데이터가 주어지는 상태에 따라 알고리즘이 달라질 수 있다

![Algorithm Design](https://public.www.evernote.com/resources/s248/992eec52-2a4c-4351-8e89-7619dbf903b2)

![Algorithm Design Strategies](https://public.www.evernote.com/resources/s248/e26ee2c1-0d5d-4ed8-b7d3-1f7851ae03ca)

1. 알고리즘 분석
    - 정확성
    - 효율성 :
         ➀ 공간 복잡도(space complexity) : 필요한 총 메모리 양
         ➁ **시간 복잡도(time complexity)** : **단위 연산 개수**보다 **입력크기의 함수**로 표현하는 것이 바람직하나, 입력이 항상 최선이라고 가정할 수 없으므로 **최악의 수행시간**을 취득

11. **<u>점근성능</u>**
    - <u>입력 크기 n이 충분히 커짐에 따라 결정되는 성능</u>
    - n이 작은 경우 각각의 계수가 중요하지만, <u>n이 클수록 최고차항이 상대적으로 중요하다</u>
     - **점근성능의 표기법** :

![Asymptotic Notation](https://public.www.evernote.com/resources/s248/23d52663-de48-4f23-a296-4943eaab680e)

![Big-Oh Notation](https://public.www.evernote.com/resources/s248/31dc2d51-5910-41ee-a12b-6ff17287f965)

    - **Big-Oh의 효율성에 따른 관계** :
         **Ο(1) < Ο(log n) < Ο(n) < Ο(n log n) < Ο(n<sup>2</sup>) < Ο(n<sup>3</sup>) < ... < Ο(2<sup>n</sup>) < Ο(n!)** _록,앤,롤,2승,3승,n승,빅토리 !_

1. 순환(재귀, recursive) 알고리즘
    - **순환 알고리즘**의 수행시간은 **점화식**으로 표현

![Recurrence Relation](https://public.www.evernote.com/resources/s248/448e3fb6-2405-4214-80c1-351d6bd2dd6c)

---

# II. 정렬

1. 정렬 알고리즘
   _서버사수(n<sup>2</sup>) 할퀴히기(nlogn), 계수열매 버킷에 담기(n)_
   _인제 안정적(O)으로 제자리(X)를 찾아야제, 버블 삽으로 머하고있노?_

![Sorting Algorithms](https://public.www.evernote.com/resources/s248/5ef61a60-fa3a-4aec-844e-bda439101421)

   - 안정적(stable) : 동일한 키값이 정렬 전후에도 상대적 위치가 불변
   - 제자리(in place) : 저장공간 이외의 별도 공간을 상수 개만 사용

---

# III. 탐색

1. 탐색
    1) 탐색(search) : 데이터에서 원하는 원소를 찾는 것
    2) 구분
         ➀ 저장장소에 따라
              내부탐색 : 모든 데이터를 주기억장치에 저장한 후 탐색
              외부탐색 : 일부 데이터 외 나머지 데이터는 외부 기억장치에 저장된 채 탐색
         ➁ 저장형태에 따라, 리스트(list), 트리(tree), 그래프(graph), 표(table), 스트링(string)

2.  **순차탐색(sequential search)**

3.  **이진탐색(binary search)**

![Binary Search](https://public.www.evernote.com/resources/s248/3776b3cb-bcd4-42cf-97b3-67beeab73cf7)

1. 탐색트리
    - 연결리스트 구조에서는 순차|이진 탐색이 어려워, 이를 트리형태로 유지함으로써 추가|삭제|탐색이 용이하도록 개발된 탐색
     1) **<u>이진 탐색트리</u>**
         ➀ **탐색** : 한 노드의 왼쪽의 키값은 작고, 오른쪽의 키값은 큰 이진트리이므로, 루트에서부터 원하는 키값을 찾아나간다
          ➁ **추가** : 추가할 원소를 탐색하다가 비교할 노드가 없으면 그 위치에 추가한다. 이미 존재한다면 종료한다
          ➂ **삭제** : 삭제할 원소를 탐색하여 삭제하고 남은 노드들의 위치를 조절한다
               - 자식이 없는 리프노드는, 삭제만 한다
               - 자식이 하나 있다면, 삭제한 노드에 자식노드(를 포함한 부분트리)를 올린다
               - **자식이 둘** 있다면, **<u>successor노드</u>**(바로 다음 키값)를 올리고, 그 자식노드를 successor 위치로 올린다
          ➃ 수행시간 : 평균 *O(log n)*, 최악(경사트리) *O(n)*

     2) **<u>2-3-4 트리</u>**
         ➀ 성질
              - 2-노드(키값1개, 자식2), 3-노드(키값2개, 자식3), 4-노드(키값3개, 자식4)
              - 한 노드의 한 키의 왼쪽의 모든 부분 트리의 키값은 작고, 오른쪽은 크다
              - 모든 리프노드의 높이는 동일하다
          ➁ 탐색
          ➂ 추가
               - 탐색과정에서 4-노드를 만나게 되면 **<u>노드분할</u>**(하나의 키를 갖는 3개의 2-노드로 상하좌우 분할)을 행한다
     3) **<u>흑적트리</u>**
         ➀ 성질
              - 이진 트리
              - 루트는 흑색
              - 리프노드는 흑색의 NULL노드를 자식으로 갖는다
              - 적색노드의 자식은 항상 흑색
              - 임의의 노드로 부터 리프노드까지의 경로상에는, 동일 개수의 흑색노드가 존재한다
              - 적색노드를 부모노드와 묶어서 표현하면 2-3-4트리가 된다
          ➁ 탐색
          ➂ 추가
               - **<u>추가하는 노드는 적색</u>**
               - **추가 후** 루트쪽으로 올라가면서 **흑적트리의 성질을 만족하도록 구조와 색깔을 조정**한다
                    현재 노드가 적색이고 부모가 적색일때
                    a. 삼촌도 적색일 경우, 부모-삼촌을 흑색으로 바꾸고 조부모를 적색으로 바꾼다
                    b-1. (삼촌이 흑색이고) 현재 키값이 부모-조부모 사이의 키값일 경우, 현재를 기준으로 오른쪽으로 **<u>회전(rotate)</u>** 시킨다(오른쪽을 내림)
                    b-2. (삼촌이 흑색이고) 현재 키값보다 부모-조부모의 키값이 크거나|작을 경우, 부모-조부모의 색깔을 바꾸고, 부모를 기준으로 왼쪽으로 회전(rotate) 시킨다(왼쪽을 내림)

5. 해싱
    1) **해싱(hashing)**
         - 탐색 키값을 기반으로 데이터의 저장위치를 직접 계산함으로써 상수시간내에 데이터를 탐색|추가|삭제할 수 있는 방법
         - 실제로 데이터의 개수보다 저장공간이 작으므로 충돌이 발생한다
    2) **해쉬함수**
         - <u>해시함수(hash function)</u> : 실제 구현과정에서 키의 형태에 무관하게 키값을 해시테이블의 주소로 변환시키기 위한 수식함수
         - 해시함수 개발의 상황 :
              a. 입력 키값의 분포를 모른다 : 상위|하위비트에 민감한 해시함수를 피하고 키 범위를 고르게 분포시키는 해시함수를 선택
              b. 입력 키값의 분포에 대해 잘못 알고있다 : 관련된 키값의 모임을 같은 해시테이블 슬롯으로 할당하는 것을 피하고 분포특성에 종속적인 해시함수를 선택
         ➀ **<u>제산</u>** 잔여(**mod** function) : mod 연산
         ➁ **<u>비닝</u>**(**bin**ning, 통에 담기) : 키값의 범위가 100개이고 해시테이블의 크기가 10일때 10개씩 나누어 담는 것
         ➂ **<u>중간</u>** 제곱(**mid**-square) : 키값을 제곱한 후 그 결과의 중간에 있는 *r*비트를 취해서 *0 ~ 2<sup>r</sup>-1* 범위의 해시결과로 사용
         ➃ 문자열을 위한 해시함수 :
              - 각 문자의 아스키 코드값을 모두 더하고 해시테이블 크기M을 사용하여 모듈러 연산을 한다
              - 4바이트씩 문자열을 처리하여 하나의 큰 정수값으로 해석한 뒤 (더 큰 범위를 갖는다), 이 정수값을 모두 더하고 모듈러 연산을 한다
         ➄ 기수변환
         ➅ 폴딩법
         ➆ 자릿수추출
     1) **<u>충돌 해결</u>**
         - 충돌(collision) : (해시함수를 사용하더라도 모든 키가 서로 다른 주소로 대응되는 것이 불가능하여) 둘 이상의 다른 키가 같은 주소로 사상되는 현상, *x ≠ y*에 대하여 *h(x) = h(y)*
         ➀ **<u>개방해싱(연쇄법)</u>** :
              - 테이블의 각 슬롯을 연결리스트의 헤드로 사용
              - 충돌된 데이터가 테이블의 밖의 장소에 저장
          ➁ **<u>폐쇄해싱(개방주소법)</u>** :
               - 충돌된 데이터가 테이블내 다른 슬롯에 저장
               a. **<u>선형 탐사</u>** : *p(K, i) = i*, 빈 슬롯을 찾을때까지 버킷의 아래쪽으로 이동, <u>1차 클러스터링</u>(레코드들이 연속된 위치를 점유하여 클러스터를 형성하는 경향) 발생
               b. **<u>이차 탐사</u>**(quadratic probing) : *p(K, i) = c<sub>1</sub>∙i<sup>2</sup> + c<sub>2</sub>∙i + c<sub>3</sub>*, <u>2차 클러스터링</u>(탐사순서가 주어진 키값이 아닌 홈위치의 함수에 의해 정해짐) 발생
               c. **<u>이중 해싱</u>**(double hashing) : *p(K, i) = i ∗ h<sub>2</sub>(K)*, 탐사순서가 원래 키값을 이용하도록 탐사함수에 대한 상수간격에 의한 선형탐사를 사용, 좋은 이중해싱은 모든 상수가 테이블크기 M에 대해 소수이어야 한다
               d. **<u>버킷 해싱</u>** : 해시테이블 슬롯을 버킷으로 묶는 것, 버킷의 빈 슬롯이 없으면 오버플로 버킷에 저장
      1) 삭제 연산
         - 해시테이블에서 삭제된 빈 슬롯은 빈 것이 아닌 비석(tombstone)을 세워 삽입,추가에 문제가 없도록 한다
         - 비석은 탐색의 평균거리를 증가시키므로, 정기적으로 테이블을 재해시하는 것이 좋다

---

# IV. 그래프

1.  **그래프의 표현**

![Graph Representations](https://public.www.evernote.com/resources/s248/b61a0bc6-b645-45ae-91b4-ba0028f7b957)

 ➀ **<u>인접행렬(adjacency matrix)</u>** : n x n 행렬을 이용한 표현방법으로
			가중치 없는 경우, G[ i ][ j ] ← 0 또는 1
			**<u>가중치 있는 경우</u>**, <u>G[ i ][ j ] ← ∞ 또는 해당 간선의 가중치</u>
 ➁ **<u>인접리스트(adjacency list)</u>** : <u>n개의 연결리스트의 첫번째 노드를 가리키기 위한 포인터 배열 head[ ]과 가중치</u>

1.  **그래프 순회**
    1) **<u>너비/깊이우선 탐색</u>**

![BFS](https://public.www.evernote.com/resources/s248/de7acb67-f30d-4492-9c1d-d5137f89f03d)

![DFS](https://public.www.evernote.com/resources/s248/055396c7-5925-4422-85e0-44161a4a706f)

 1) 그래프 순회의 응용
          ➀ **<u>위상정렬(topological sort)</u>** : 사이클이 없는 방향그래프의 정점을 한 줄로 나열하는 것

![Topological Sort](https://public.www.evernote.com/resources/s248/210fe4e4-802a-4168-85b0-66e5e0388150)

          ➁ **그래프의 연결성**

![Graph Connectivity](https://public.www.evernote.com/resources/s248/d766ce20-03e9-4919-ba9d-7d5e3fb9bdee)

1.  **최소 신장 트리**
    - 신장트리(spanning tree) : 연결된 가중치 무방향 그래프에서 주어진 정점을 모두 포함하는 연결된 부분그래프 중 트리인 것
    - **<u>최소신장트리</u>(minimum spanning tree)** : **<u>연결된 가중치 무방향 그래프에서 가중치의 합이 가장 작은 신장 트리</u>**
    1) **크루스칼(Kruskal)**

![Kruskal's Algorithm](https://public.www.evernote.com/resources/s248/faeae13f-3031-4fa5-b753-85f05a7feeba)

    1) **프림(Prim)**

![Prim's Algorithm](https://public.www.evernote.com/resources/s248/79d3466b-d2fa-4ce4-95f2-7fc36e269f73)

1.  **<u>최단 경로(shortest path)</u>** : 가중치 방향그래프에서 두 정점을 연결하는 경로 중에서 간선의 가중치 합이 가장 작은 경로

![Shortest Path](https://public.www.evernote.com/resources/s248/d6550953-c395-4fd4-8c6f-5d3ce92ebd22)

---

# V. 스트링 알고리즘

1.  **스트링 매칭**
    - 텍스트(text)에서 패턴(pattern)이 나타나는 곳을 찾는 것
     - 접근 방식에 따라, 패턴 전처리 방식(에디터), 텍스트 전처리 방식(DNA문자열)
    1) **<u>브루트-포스(Brute-force)</u>/Naive/무자별 대입 공격**
         - 텍스트의 모든 위치에서 패턴이 나타나는지 찾는 방법, 수행시간 *O(mn)*
         - 텍스트와 패턴의 첫위치를 맞추어 정렬 후, 패턴의 끝문자까지 불일치가 일어나지 않으면 성공, 불일치가 일어나면 다음 문자에서 첫위치를 다시 맞추어 비교한다

![Brute Force String Matching](https://public.www.evernote.com/resources/s248/e33a33d5-2b5a-4fb2-b7b9-76edda8f09e2)

1) **<u>라빈-카프(Rabin-Karp)</u>**
		 - 패턴의 해시(hash)값으로 매치의 후보를 찾아서 그 후보에 대해서만 문자별로 비교, 수행시간 최악 *O(mn)*, 최선 O*(m+n)*
2) **<u>KMP(Knuth Morris Pratt)</u>**
		 - 패턴을 전처리하여(패턴의 모든 접두부에 대하여 접두부(prefix)와 접미부(suffix)가 일치하는 경우를 계산),
			 접미부와 일치하는 **<u>진접두부</u>**를 구하고 이 정보를 이용하여 매칭, 수행시간 *O(m+n)*
		 - 패턴 내의 문자들의 관계를 이용하여, 비교할 필요가 없는 중복된 비교를 줄이며 패턴을 찾는 방법, 앞부분부터 매칭
		 - 앞부분부터 매칭하여 일치하지 않는 부분의 왼쪽을 가지고, 패턴의 접두부(prefix)와 접미부(suffix)가 동일한 경우를 찾는다, 그 사이를 경계라 한다
3) **<u>보이어-무어(Boyer-Moore)</u>**
		 - KMP와 동일하게 비교할 필요가 없는 중복된 비교를 줄이며 패턴을 찾는 방법하지만, 뒤부분부터 매칭을 한다, 수행시간 - 최악 *O(mn)*, 최선 *O(n/m)*
		 ➀ **<u>불일치 문자(bad character)</u>** 방법 : 불일치가 발생할 경우, 패턴내 해당 불일치 문자가 가장 마지막에 나타나는 위치를 찾아, 패턴을 텍스트와 일치하도록 이동
		 ➁ **<u>일치 접미부(good suffix)</u>** 방법 : 접두부와 접미부가 일치하는 부분을 사용하나, KMP와 반대로 패턴의 오른쪽 부분 문자열을 전처리한다

1.  **데이터 압축**
    - **<u>무손실 압축</u>**(RLE, 허프만 코딩, LZ77)
    - 인코딩(encoding, 압축된 데이터로 변환), 디코딩(decoding, 원래의 데이터로 역변환)
    1) **<u>RLE(Run Length Encoding)</u>**
         - 스트링에서 동일 문자가 인접하게 반복되어 나타나는 것(run)을 그 문자와 반복횟수로 압축, 수행시간 O(n)
         - 일반문서에 비해 영상데이터 압축에 효과적
         - (예) aaabbbbbcaa → (a,3) (b,5) (c,1) (a,2)
    2) **<u>허프만 코딩(Huffman coding)</u>**
         - 스트링에서 **<u>빈도가 높은 문자는 짧은 코드로, 빈도가 낮은 문자는 긴코드로 변환</u>**하여 압축, 수행시간 *O( |∑| log|∑| + n )*
         - 빈도가 낮은 문자부터 **<u>이진트리</u>**를 만들어가며 <u>접두부 코드를 구한 뒤</u>, 압축
         - 접두부 코드 작성 :
              빈도가 가장 낮은 두 개의 정점을 뽑아 이진트리의 부모(두 자녀의 값의 합)를 만들고, 이를 남은 정점에 추가한다
              남은 정점들에서 빈도가 가장 낮은 두 개의 정점을 뽑는 식으로. 동일한 과정을 반복한다

![Huffman Coding](https://public.www.evernote.com/resources/s248/1905fe2a-e869-419f-9695-1aedd4e98ca8)

    1) **<u>LZ(Lempel-Ziv) 77</u>**
         - 현재 문자열 대신 **<u>앞서 나온 반복되는 문자열의 위치와 길이로 변환</u>**하여 압축
         - **<u>슬라이딩 윈도(sliding window)</u>** : 앞으로 나올 문자 L<sub>s</sub>개(탐색버퍼, 현재의 사전)와 지나간 문자열중 마지막 문자 L<sub>L</sub>개(전향버퍼)를 표시하여, 비교하기에 사용한다
         - (예) abcdeabcdfi → (0,0,a) (0,0,b) (0,0,c) (0,0,d) (0,0,e) (5,4,f) (0,0,i)

1. 이미지 압축
    - **<u>손실 압축</u>**(JPEG, MPEG)
    1) **JPEG**(Joint Photographic Experts Group)
         - (일반적으로 인접한 부분에서는 색상이 급격하게 변하지 않는다는 특성을 이용하여)
         - 2차원 데이터를 단위 블록으로 나눈 뒤 블록별로 압축
         - **압축단계** : *b.cd.q.e*
              ➀ **블록화**(block) : 데이터를 8x8 블록으로 만듬
               ➁ **DCT**(discrete cosine transform)
               ➂ **양자화**(quantization) : 큰값을 작은값으로 표현해주는 과정
                    ➃ 엔트로피 코딩(entropy coding)

4. 동영상 압축
     1) MPEG(Moving Picture Experts Group)
          - (일반적으로 연속된 시간의 2차원 이미지들이 급격하게 변하지 않는다는 특성을 이용하여)
          - 시간순으로 나열된 2차원 데이터를 연속된 시간의 특성을 이용하여 압축
          - JPEG + 움직임 벡터(motion vector)

---

# VI. 동적 프로그래밍

1. **동적 프로그래밍**
   - 주어진 문제에 대해서 최적해를 제공하는 **<u>재귀 관계식(점화 관계식)</u>**을 도출한다 : **<u>최적성의 원리</u>**<u>(주어진 문제의 최적해가 분할된 부분 문제에 대한 최적해로 구성된다)</u>
   - 가장 작은 부분 문제부터 점화식의 해를 구한뒤 이를 **<u>테이블에 저장</u>**한다 : 이를 프로그래밍이라 함
   - 이 해를 이용하여 점차적으로 입력 크기가 큰 <u>상위 문제의 해를 구한다</u> : <u>상향식(bottom-up) 접근법</u>

2. **연쇄 행렬 곱셈**
   - *n*개의 행렬을 곱하는 최적의(최소의 곱셈 횟수를 가진) 곱셈 순서를 구하는 것
   - 수행시간 *O(n<sup>3</sup>)*

3. **<u>스트링 편집 거리(edit distance)</u>**
   - 두 개의 문자열 사이의 편집거리는 문자열 X를 문자열 Y로 변환하는데 필요한 전체 편집연산(삽입,삭제,변경)에 대한 최소비용을 의미한다
   - 일반적으로 편집 거리가 클수록 두 스트링의 유사도는 낮아진다
   - **과정** :
     - ➀ 최적해와 부분 문제들의 관계 분석(최적 부분 구조 분석)
     - ➁ 점화식 세우기
     - ➂ 최적해의 값 구하기
   - 수행시간 ***O(mn)***

---

# VII. NP-완전 문제

1. 클래스 NP
   1) <u>(결정론적) 튜링 기계</u> : 읽고 쓸 수 있는 무한한 길이의 테이프를 가지며, 유한한 개수의 입력 기호와 테이프의 현재 위치에 쓰인 기호에 따라 (한 가지의 상태로만) 테이프의 위치를 바꾼다거나 쓰인 기호를 바꿀 수 있는 기계
   2) <u>비결정론적 튜링 기계</u> : 테이프의 위치를 바꾸거나 쓰인 기호를 바꿀때 하나 이상의 상태로 바뀔 수 있거나 혹은 없을 수 있다
   3) <u>다항시간 알고리즘</u> : 수행시간이 입력의 크기에 대한 <u>다항식으로 표현되는 알고리즘</u>
     - <u>다루기 쉬운(tractable) 문제</u> : 튜링 기계를 이용한 다항시간 알고리즘이 존재하는 문제
     - 다루기 어려운(untractable) 문제 : 튜링 기계를 이용한 다항시간 알고리즘이 존재하는지 알 수 없는 문제
   4) <u>판정 문제</u> : 예 혹은 아니오 중 하나를 답으로 요구하는 문제
   5) **<u>클래스 P</u>** : **<u>(결정론적) 튜링 기계</u>**<u>를 이용한 </u>**<u>다항시간</u>**<u>에 해결할 수 있는 </u>**<u>모든 판정 문제</u>** ***튜링*** *이* ***다*** *!*
   6) **<u>클래스 NP</u>** : **<u>비결정론적 튜링 기계</u>**<u>를 이용하여 </u>**<u>다항시간</u>**<u>에 해결할 수 있는 </u>**<u>모든 판정 문제</u>** ***튜링*** *이* ***아니.다*** *!*
   7) **<u>변환(reduction)</u>** : **문제A의 입력과 출력을 문제B의 입력과 출력 형태로 바꿀 수 있고**, 여기에 문제 B를 해결하는 알고리즘을 적용함으로써 **궁극적으로 문제A를 풀 수 있다**는 것
   8) <u>근사 알고리즘</u> : 최적화 문제에 대하여  최적의 해에 가까운(근사한) 해를 구하는 알고리즘
     - 최적의 해를 구하는 것보다 짧은 수행시간에 해를 구할 수 있다
     - <u>최소 신장 트리</u>를 이용한다
     - 최소 신장트리 < 최적해 < 근사해

2. **<u>NP-완전(NP-complete) 문제</u>**
   - 클래스 NP에 속하는 모든 문제가 주어진 어떤 문제로 다항식 시간에 변환되고 그 문제가 클래스 NP에 속하는 경우
   * <u>해</u>라<u>클</u>래스가 <u>파</u>도를 <u>버티</u>는지 <u>CNF</u>성에서 온 <u>외궤</u>인과 <u>30</u>원 완전 내기를 했다 !*
     ➀ **해**밀토니언 사이클 문제
     ➁ **클리**크 판정 문제
     ➂ **파티**션 문제
     ➃ **버텍**스 커버 문제
     ➄ **CNF** 만족성 문제
     ➅ **<u>외</u>**<u>판원 문제(TSP, traveling salesman problem)</u> : 주어진 비용보다 적은 비용으로 모든 도시를 한 번씩만 방문하고 돌아오는 방법이 존재하는가?
     ➆ **궤** 채우기 문제
     ➇ **3**-CNF 만족성 문제
     ➈ **0/1** 배낭 문제

---

# VIII. 병렬 알고리즘

1. 병렬 알고리즘
   - 여러 프로세서를 이용하여 동시에 명령을 수행할 수 있는 알고리즘
   - 쿼드코어 시스템, 분산처리 시스템

2. **병렬계산 모델**
   - PRAM, PMH, BSP, LogP
   1) **<u>PRAM</u>**<u>(Parallel Random Access Machine)</u>**<u> 모델</u>**
     - *p*개의 프로세서가 동시에 독립적인 명령어를 수행할 수 있고 공유메모리를 사용하는 병렬계산 모델
   2) 작업량
     - 순차 알고리즘 : 짧은 시간과 적은 공간을 차지할수록 좋은 알고리즘
     - 병렬 알고리즘 : 짧은 시간과 적은 프로세서 개수를 사용할수록 좋은 알고리즘
     - **<u>작업량 : 수행시간(</u>*T*<u>)과 프로세서 개수(</u>*p*<u>)의 곱</u>** = *P(n)* \* *p*, 작업량이 많을수록 비효율적
     - **<u>시간효율성</u>** : *(S(n) / p) / P(n)*

![Screen Shot 2016-06-21 at 6.39.01 PM.png](https://public.www.evernote.com/resources/s248/30fa5bbc-13e8-490b-9f6a-49317b2e220f)

![Screen Shot 2018-10-10 at 3.07.33 AM.png](https://public.www.evernote.com/resources/s248/d0febc86-b629-4512-95c9-e69fbd3e2fb8)

---

# IX. 유전 알고리즘

1. 유전 알고리즘 (genetic algorithm, GA)
   - 1970년 존 홀랜드(John Holland)
   - 자연계의 진화를 통해 관찰된 메커니즘을 모방하여 최적화 문제(탐색공간에서 더 좋은 해를 찾는 것)를 해결하기 위한 탐색 방법

2. **<u>유전 알고리즘의 전형적인 처리과정</u>**
   1) 특징
     - <u>찰스 다윈의 자연계의 진화 시스템</u>의 원칙에 따름 : **<u>자연선택(selection,적자생존) → 교차(crossover,짝짓기) →</u>** **<u>변이(mutation)</u>**
     - 연속적인 세대를 거치면서 개체 사이의 적자생존을 모방
     - 각 <u>개체</u>는 하나의 가능한 <u>해법</u>을 함축하고 있는 <u>염색체로 표현</u>

   ![Screen Shot 2016-06-21 at 11.58.22 PM.png](https://public.www.evernote.com/resources/s248/b79c5d6b-b7fc-407a-ad09-ef67d15d946b)
     - 염색체 정보의 결합을 통해서 더 나은 자손을 생성하기 위해 각각 <u>적합도 점수가 부여된 해를 선택적으로 키워 나가는 방법</u>을 이용
     - 인공지능 방법들보다 사소한 변화나 잡음에 강하고, 상태 공간의 탐색에 있어서 전형적인 최적화 탐색 방법보다 의미있는 결과를 제공
   1) 기본 처리과정
     - ➀ [초기화] 난수를 사용해 n개의 염색체로 이루어진 개체군을 생성
     - ➁ [적합도] 각 염색체에 대해 적합도 점수를 계산
     - ➂ [새 개체군] 선택, 교차, 변이, 저장의 과정을 반복
     - ➃ [대체] 새 개체군으로 대체
     - ➄ [종료검사]
     - ➅ [반복]

3. **<u>유전 알고리즘의 연산자</u>**

   ![Screen Shot 2016-06-20 at 11.32.43 PM.png](https://public.www.evernote.com/resources/s248/9f991d95-d37f-48b3-b17d-9627fa4ab72c)

4. 유전 알고리즘의 매개변수
   - 교차 확률
   - 변이 확률
   - 개체군의 크기

5. 유전 알고리즘의 응용
   - 병렬성에 유리
   - 구현이 용이
   - 많은 계산시간이 소요
