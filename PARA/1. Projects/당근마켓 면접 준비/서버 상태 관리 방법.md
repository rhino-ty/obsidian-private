---
sticker: emoji//1fae1
---
리액트에서 서버 상태를 관리하는 기본적인 패턴들을 구현해보겠습니다.

```tsx
// 1. Custom Hook Pattern with Loading/Error States
function useUsers() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchUsers = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch('api/users');
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  return { users, loading, error, refetch: fetchUsers };
}

// Usage
function UserList() {
  const { users, loading, error, refetch } = useUsers();

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={refetch}>Refresh</button>
      {users.map(user => <div key={user.id}>{user.name}</div>)}
    </div>
  );
}

// 2. Context + Reducer Pattern for Global Server State
const ServerStateContext = createContext();

const initialState = {
  data: null,
  loading: false,
  error: null,
  timestamp: null
};

function serverStateReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return {
        ...state,
        loading: false,
        data: action.payload,
        timestamp: Date.now()
      };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
}

function ServerStateProvider({ children }) {
  const [state, dispatch] = useReducer(serverStateReducer, initialState);
  
  const fetchData = async (url) => {
    dispatch({ type: 'FETCH_START' });
    try {
      const response = await fetch(url);
      const data = await response.json();
      dispatch({ type: 'FETCH_SUCCESS', payload: data });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  };

  return (
    <ServerStateContext.Provider value={{ state, fetchData }}>
      {children}
    </ServerStateContext.Provider>
  );
}

// 3. Cache Layer Pattern
function createCache() {
  const cache = new Map();
  
  return {
    get: (key) => {
      const item = cache.get(key);
      if (!item) return null;
      
      const isExpired = Date.now() - item.timestamp > item.ttl;
      if (isExpired) {
        cache.delete(key);
        return null;
      }
      
      return item.data;
    },
    
    set: (key, data, ttl = 5 * 60 * 1000) => {
      cache.set(key, {
        data,
        timestamp: Date.now(),
        ttl
      });
    }
  };
}

function useDataWithCache(url) {
  const cache = useMemo(() => createCache(), []);
  const [data, setData] = useState(() => cache.get(url));
  const [loading, setLoading] = useState(!data);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async (force = false) => {
    if (!force) {
      const cachedData = cache.get(url);
      if (cachedData) {
        setData(cachedData);
        return;
      }
    }

    setLoading(true);
    try {
      const response = await fetch(url);
      const newData = await response.json();
      cache.set(url, newData);
      setData(newData);
      setError(null);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [url, cache]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: () => fetchData(true) };
}
```

위 코드에서 세 가지 주요 패턴을 구현했습니다:

1. **Custom Hook Pattern**
   - 기본적인 로딩/에러 상태 관리
   - 컴포넌트별 독립적인 상태 관리
   - 재사용 가능한 데이터 페칭 로직

2. **Context + Reducer Pattern**
   - 전역 서버 상태 관리
   - 액션 기반의 상태 업데이트
   - 여러 컴포넌트에서 공유 가능한 상태

3. **Cache Layer Pattern**
   - 메모리 캐싱 구현
   - TTL(Time To Live) 기반 캐시 만료
   - 중복 요청 방지

이런 패턴들은 React Query가 없을 때도 효과적인 서버 상태 관리가 가능하게 해줍니다. 특히 면접 상황에서는 이러한 기본 패턴들을 이해하고 있다는 것을 보여줄 수 있죠.

각 패턴의 장단점도 알아두면 좋습니다:
- **Custom Hook** : 구현이 간단하지만 캐싱이나 재검증 기능이 없음
- **Context + Reducer** : 전역 상태 관리가 가능하지만 컴포넌트 트리가 커지면 성능 이슈 발생 가능
- **Cache Layer** : 중복 요청을 방지하고 성능을 개선할 수 있지만 구현이 복잡하고 메모리 관리가 필요

면접에서는 이러한 패턴들의 Trade-off를 설명하고, 상황에 따라 적절한 패턴을 선택할 수 있다는 것을 보여주면 좋을 것 같습니다.