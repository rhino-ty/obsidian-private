---
sticker: emoji//1fae1
---
리액트에서 서버 상태를 관리하는 기본적인 패턴들을 구현해보겠습니다.

```tsx
// 1. Custom Hook Pattern with Loading/Error States
function useUsers() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchUsers = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const response = await fetch('api/users');
      const data = await response.json();
      setUsers(data);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  return { users, loading, error, refetch: fetchUsers };
}

// Usage
function UserList() {
  const { users, loading, error, refetch } = useUsers();

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <button onClick={refetch}>Refresh</button>
      {users.map(user => <div key={user.id}>{user.name}</div>)}
    </div>
  );
}

// 2. Context + Reducer Pattern for Global Server State
const ServerStateContext = createContext();

const initialState = {
  data: null,
  loading: false,
  error: null,
  timestamp: null
};

function serverStateReducer(state, action) {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, loading: true, error: null };
    case 'FETCH_SUCCESS':
      return {
        ...state,
        loading: false,
        data: action.payload,
        timestamp: Date.now()
      };
    case 'FETCH_ERROR':
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
}

function ServerStateProvider({ children }) {
  const [state, dispatch] = useReducer(serverStateReducer, initialState);
  
  const fetchData = async (url) => {
    dispatch({ type: 'FETCH_START' });
    try {
      const response = await fetch(url);
      const data = await response.json();
      dispatch({ type: 'FETCH_SUCCESS', payload: data });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  };

  return (
    <ServerStateContext.Provider value={{ state, fetchData }}>
      {children}
    </ServerStateContext.Provider>
  );
}

// 3. Cache Layer Pattern
function createCache() {
  const cache = new Map();
  
  return {
    get: (key) => {
      const item = cache.get(key);
      if (!item) return null;
      
      const isExpired = Date.now() - item.timestamp > item.ttl;
      if (isExpired) {
        cache.delete(key);
        return null;
      }
      
      return item.data;
    },
    
    set: (key, data, ttl = 5 * 60 * 1000) => {
      cache.set(key, {
        data,
        timestamp: Date.now(),
        ttl
      });
    }
  };
}

function useDataWithCache(url) {
  const cache = useMemo(() => createCache(), []);
  const [data, setData] = useState(() => cache.get(url));
  const [loading, setLoading] = useState(!data);
  const [error, setError] = useState(null);

  const fetchData = useCallback(async (force = false) => {
    if (!force) {
      const cachedData = cache.get(url);
      if (cachedData) {
        setData(cachedData);
        return;
      }
    }

    setLoading(true);
    try {
      const response = await fetch(url);
      const newData = await response.json();
      cache.set(url, newData);
      setData(newData);
      setError(null);
    } catch (err) {
      setError(err);
    } finally {
      setLoading(false);
    }
  }, [url, cache]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: () => fetchData(true) };
}
```

위 코드에서 세 가지 주요 패턴을 구현했습니다:

1. **Custom Hook Pattern**
   - 기본적인 로딩/에러 상태 관리
   - 컴포넌트별 독립적인 상태 관리
   - 재사용 가능한 데이터 페칭 로직

2. **Context + Reducer Pattern**
   - 전역 서버 상태 관리
   - 액션 기반의 상태 업데이트
   - 여러 컴포넌트에서 공유 가능한 상태

3. **Cache Layer Pattern**
   - 메모리 캐싱 구현
   - TTL(Time To Live) 기반 캐시 만료
   - 중복 요청 방지

이런 패턴들은 React Query가 없을 때도 효과적인 서버 상태 관리가 가능하게 해줍니다. 특히 면접 상황에서는 이러한 기본 패턴들을 이해하고 있다는 것을 보여줄 수 있죠.

각 패턴의 장단점도 알아두면 좋습니다:
- **Custom Hook** : 구현이 간단하지만 캐싱이나 재검증 기능이 없음
- **Context + Reducer** : 전역 상태 관리가 가능하지만 컴포넌트 트리가 커지면 성능 이슈 발생 가능
- **Cache Layer** : 중복 요청을 방지하고 성능을 개선할 수 있지만 구현이 복잡하고 메모리 관리가 필요

면접에서는 이러한 패턴들의 Trade-off를 설명하고, 상황에 따라 적절한 패턴을 선택할 수 있다는 것을 보여주면 좋을 것 같습니다.

### useSyncExternalStore 사용
useSyncExternalStore는 서버 상태 관리에 매우 유용한 훅입니다. 특히 외부 데이터 소스와의 동기화에 적합하죠.

예시와 함께 살펴보겠습니다:
```tsx
// 서버 상태를 관리하는 외부 스토어 생성
function createServerStore(initialState = { data: null, loading: false, error: null }) {
  let state = initialState;
  const listeners = new Set();

  return {
    subscribe: (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    },
    
    getSnapshot: () => state,

    // 상태 업데이트 및 리스너 호출
    setState: (newState) => {
      state = typeof newState === 'function' ? newState(state) : newState;
      listeners.forEach(listener => listener());
    },

    // 데이터 페칭 메서드
    async fetch(url) {
      this.setState(prev => ({ ...prev, loading: true, error: null }));
      
      try {
        const response = await fetch(url);
        const data = await response.json();
        this.setState(prev => ({ 
          ...prev, 
          data, 
          loading: false,
          timestamp: Date.now() 
        }));
      } catch (error) {
        this.setState(prev => ({ 
          ...prev, 
          error, 
          loading: false 
        }));
      }
    }
  };
}

// 스토어 인스턴스 생성
const userStore = createServerStore();

// 커스텀 훅으로 스토어 사용
function useUserData(url) {
  const state = useSyncExternalStore(
    userStore.subscribe,
    userStore.getSnapshot,
    // SSR을 위한 서버 스냅샷 (옵션)
    () => userStore.getSnapshot()
  );

  useEffect(() => {
    userStore.fetch(url);
  }, [url]);

  return state;
}

// 컴포넌트에서 사용
function UserList() {
  const { data, loading, error } = useUserData('/api/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {data?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// 여러 데이터 소스를 관리하는 더 일반화된 버전
function createExternalStore() {
  const stores = new Map();
  
  function getOrCreateStore(key) {
    if (!stores.has(key)) {
      stores.set(key, createServerStore());
    }
    return stores.get(key);
  }

  return {
    useData: (key, url) => {
      const store = getOrCreateStore(key);
      
      const state = useSyncExternalStore(
        store.subscribe,
        store.getSnapshot,
        store.getSnapshot
      );

      useEffect(() => {
        store.fetch(url);
      }, [url]);

      return state;
    }
  };
}

const externalStore = createExternalStore();

// 여러 데이터 소스 사용 예시
function Dashboard() {
  const users = externalStore.useData('users', '/api/users');
  const posts = externalStore.useData('posts', '/api/posts');
  
  return (
    <div>
      {/* users와 posts 데이터를 사용한 UI 렌더링 */}
    </div>
  );
}
```

useSyncExternalStore의 주요 장점들입니다:

1. **동시성 보장**
   - React 18의 concurrent features와 호환
   - tearing 현상 방지
   - 데이터 일관성 보장

2. **외부 스토어와의 자연스러운 통합**
   - 구독 기반 업데이트 메커니즘
   - 스토어의 변경사항을 자동으로 감지하고 리렌더링

3. **SSR 지원**
   - getServerSnapshot을 통한 서버 사이드 렌더링 지원
   - hydration 불일치 방지

4. **성능 최적화**
   - 불필요한 리렌더링 방지
   - 세밀한 구독 관리

주의할 점은:
- 구독 로직을 직접 구현해야 함
- 상태 업데이트 로직이 복잡해질 수 있음
- 캐싱, 재시도 등의 기능은 직접 구현 필요

면접에서는 "**왜 useSyncExternalStore를 선택했는지**"를 설명할 수 있어야 합니다. 특히 동시성 모드와의 호환성이나 데이터 일관성 측면에서의 이점을 강조하면 좋을 것 같네요.

`useSyncExternalStore`를 선택한 이유와 그 이점을 설명하겠습니다:

1. 동시성 모드 호환성
    - React 18의 동시성 모드에서 발생할 수 있는 'tearing' 문제를 해결합니다.
    - 'tearing'은 UI의 일부가 오래된 상태를 표시하는 문제로, `useSyncExternalStore`는 이를 방지하여 일관된 UI를 보장합니다.
2. 데이터 일관성
    - 외부 상태와 React 컴포넌트 간의 동기화를 보장합니다.
    - 렌더링 도중 상태가 변경되어도 해당 렌더링 주기 동안 일관된 스냅샷을 유지합니다.
3. 성능 최적화
    - 필요한 상태만 선택적으로 구독할 수 있어 불필요한 리렌더링을 방지합니다.
    - 상태 변경 시 효율적인 업데이트 메커니즘을 제공합니다.
4. 외부 상태 관리 용이성
    - Redux, MobX 등 외부 상태 관리 라이브러리와의 통합이 쉽습니다.
    - 커스텀 상태 관리 솔루션 구현 시 React의 렌더링 사이클과 자연스럽게 통합됩니다.
5. 서버 사이드 렌더링(SSR) 지원
    - SSR 환경에서도 안정적으로 작동하며, 클라이언트와 서버 간 상태 불일치 문제를 해결합니다.
        