- 한마디: 함수와 함수가 선언된 어휘적 환경의 조합입니다. 내부 함수가 외부 함수의 변수에 접근할 수 있는 것을 의미.
- 어휘적 환경이 뭐죠?

> 함수가 선언된 주변 환경을 의미합니다. 주로 외부 함수(outer function)의 변수가 내부 함수(inner function)의 어휘적 환경에 포함됩니다. 그래서 내부 함수가 리턴되어도 나중에 클로저의 어휘적 환경에 접근하여 외부 함수의 변수에 접근할 수 있습니다.

- 그래서 클로저를 언제 쓰나요?

> 클로저는 사실 자바스크립트의 어떤 함수든 가지고 있습니다. 어떤 함수든 전역 변수에 접근할 수 있기 때문입니다. 그래서 언제나 쓰이고 있습니다. 자바스크립트에서 private 메서드를 구현하기 위해서도 클로저를 활용할 수 있습니다. 클로저 내에 있는 변수는 외부에서 접근할 수 없기 때문에, 클로져 내에 있는 변수를 활용 할 수 있는 private 메서드만 따로 노출시켜서 인터페이스처럼 사용할 수 있게 됩니다.

- 예시 1 : 리액트에서 상태 관리하기

```jsx
import React, { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
};
```

위 코드에서 **`useState`**는 상태 관리를 위한 Hook입니다. 이 Hook을 사용하여 **`count`** 상태와 **`setCount`** 함수를 선언합니다. **`handleIncrement`** 함수는 **`count`** 상태를 변경하는 역할을 합니다.

이때, **`handleIncrement`** 함수는 **`useState`** 함수 내부에서 선언된 **`count`** 상태에 접근합니다. **`useState`** 함수는 클로저를 활용하여 **`count`** 상태를 **`handleIncrement`** 함수 내에서 계속해서 사용할 수 있도록 합니다.

- 예시 2 : 바닐라 JS

```jsx
function createCounter() {
  let count = 0;
  return function () {
    debugger;
    count += 1;
    return count;
  };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

#### 클로저 사용해 useState 구현해보기

클로저를 사용해 React의 `useState`를 구현한다면 다음과 같이 접근할 수 있습니다:

```javascript
function createUseState(initialValue) {
  let state = initialValue; // 클로저를 통해 유지될 상태값
  
  function setState(newValue) {
    state = newValue;
    // 실제 React에서는 여기서 컴포넌트 리렌더링을 트리거
    render();
  }
  
  // 상태값과 상태 변경 함수를 배열로 반환
  return [state, setState];
}

// 사용 예시
function Counter() {
  const [count, setCount] = createUseState(0);
  
  return {
    increment: () => setCount(count + 1),
    getCount: () => count
  };
}
```

1. 클로저를 통한 상태 유지
   - `createUseState` 함수 내부의 `state` 변수는 클로저를 통해 유지됨
   - `setState` 함수가 이 `state` 변수에 계속 접근 가능

2. 실제 React와의 차이점
   - 실제 React의 `useState`는 훨씬 복잡한 구현을 가짐
   - 컴포넌트별 상태 관리, 리렌더링 처리 등이 추가로 필요

3. 한계점
   - 이 단순 구현은 컴포넌트 리렌더링을 직접 처리하지 않음
   - 여러 상태값 관리나 동시성 처리 등이 고려되지 않음

단, 이것은 매우 단순화된 구현이며, 실제 React의 `useState`는 Fiber 아키텍처, 리렌더링 큐, 배치 업데이트 등 훨씬 복잡한 메커니즘을 포함합니다.