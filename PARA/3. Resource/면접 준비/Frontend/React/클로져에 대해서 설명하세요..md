- 한마디: 함수와 함수가 선언된 어휘적 환경의 조합입니다. 내부 함수가 외부 함수의 변수에 접근할 수 있는 것을 의미.
- 어휘적 환경이 뭐죠?

> 함수가 선언된 주변 환경을 의미합니다. 주로 외부 함수(outer function)의 변수가 내부 함수(inner function)의 어휘적 환경에 포함됩니다. 그래서 내부 함수가 리턴되어도 나중에 클로저의 어휘적 환경에 접근하여 외부 함수의 변수에 접근할 수 있습니다.

- 그래서 클로저를 언제 쓰나요?

> 클로저는 사실 자바스크립트의 어떤 함수든 가지고 있습니다. 어떤 함수든 전역 변수에 접근할 수 있기 때문입니다. 그래서 언제나 쓰이고 있습니다. 자바스크립트에서 private 메서드를 구현하기 위해서도 클로저를 활용할 수 있습니다. 클로저 내에 있는 변수는 외부에서 접근할 수 없기 때문에, 클로져 내에 있는 변수를 활용 할 수 있는 private 메서드만 따로 노출시켜서 인터페이스처럼 사용할 수 있게 됩니다.

- 예시 1 : 리액트에서 상태 관리하기

```jsx
import React, { useState } from "react";

const Counter = () => {
  const [count, setCount] = useState(0);

  const handleIncrement = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleIncrement}>Increment</button>
    </div>
  );
};
```

위 코드에서 **`useState`**는 상태 관리를 위한 Hook입니다. 이 Hook을 사용하여 **`count`** 상태와 **`setCount`** 함수를 선언합니다. **`handleIncrement`** 함수는 **`count`** 상태를 변경하는 역할을 합니다.

이때, **`handleIncrement`** 함수는 **`useState`** 함수 내부에서 선언된 **`count`** 상태에 접근합니다. **`useState`** 함수는 클로저를 활용하여 **`count`** 상태를 **`handleIncrement`** 함수 내에서 계속해서 사용할 수 있도록 합니다.

- 예시 2 : 바닐라 JS

```jsx
function createCounter() {
  let count = 0;
  return function () {
    debugger;
    count += 1;
    return count;
  };
}
const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```