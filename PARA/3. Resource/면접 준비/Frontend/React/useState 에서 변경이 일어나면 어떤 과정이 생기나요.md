---
sticker: emoji//2b50
tags:
  - react
  - useState
---
### 핵심 답변
useState의 상태 변경 시에는 다음 프로세스가 발생합니다.

1. setState 호출 → 새로운 상태값 큐잉
2. React가 리렌더링 스케줄링
3. 컴포넌트 함수 재실행 
4. Virtual DOM 생성/비교
5. 필요한 부분만 실제 DOM 업데이트
#### 주요 특징
- 상태 업데이트는 비동기적
- 배치(batch) 처리로 여러 업데이트 최적화
- 이전 상태 값을 기반으로 업데이트 시 함수형 업데이트 권장

### 자세한 답변
1. **상태 변경 감지**
   * `useState` 훅을 사용하면, 리액트는 내부적으로 해당 컴포넌트의 상태를 추적합니다.
   * 상태 업데이트 함수(`setState`)가 호출되면, 리액트는 해당 컴포넌트를 "`더티`(dirty)"로 표시합니다.
   * Closure를 통한 상태 값 보존 메커니즘
2. **렌더링 큐**
   * 리액트는 상태 변경이 발생한 컴포넌트들을 렌더링 큐에 추가합니다.
   * 동시성(Concurrent) 모드 : 렌더링 작업의 우선순위를 동적으로 조정
	   * Concurrent Rendering의 작동 방식
	   * `startTransition`의 동작 방식
	   - `Suspense`와의 연계
   * 이 과정은 비동기적으로 이루어져, 여러 상태 변경을 배치 처리할 수 있습니다.
3. **재조정(Reconciliation)**
   * 렌더링 단계에서 리액트는 "`더티`" 컴포넌트들을 새로 렌더링합니다.
   * 이 때 가상 DOM 트리를 새로 생성하고, 이전 트리와 비교합니다(Diffing).
   * Render Phase와 Commit Phase의 구분
   - 작업 우선순위에 따른 렌더링 인터럽트
4. **부분 렌더링**
   * Diffing 과정에서 변경된 부분만 식별됩니다.
   * 리액트는 이 정보를 사용해 실제 DOM에서 필요한 부분만 업데이트합니다.
5. **최적화**
   * `React.memo`, `useMemo`, `useCallback` 등을 통해 불필요한 리렌더링을 방지할 수 있습니다.
   * 이들은 `props`나 의존성이 변경되지 않았을 때 컴포넌트나 값의 재계산을 막습니다.
6. **Fiber 아키텍처**
   * 리액트의 Fiber 아키텍처는 렌더링 작업을 작은 단위로 나누어 우선순위를 관리합니다.
   * 이를 통해 중요한 업데이트를 먼저 처리하고, 렌더링 과정을 중단하거나 재개할 수 있습니다.
   - Double Buffering으로 current tree와 workInProgress tree를 관리
   - `child`, `sibling`, `return` 포인터로 fiber 노드들을 연결하는 구조