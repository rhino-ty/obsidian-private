---
sticker: emoji//2b50
tags:
  - network
  - graphql
  - RESTfulAPI
aliases:
  - GraphQL vs RESTful API
---
"GraphQL이 뭔가요? RESTful API 와 비교해 장단점은 무엇인가요?"

옛날에 내 GitHub 프로필 불러온다고, 그래프큐엘로 커밋

### GraphQL 정의
- Facebook에서 개발한 API 쿼리 언어 및 런타임
- 클라이언트가 필요한 데이터를 정확하게 요청 가능
- 단일 엔드포인트에서 여러 리소스 처리

### 주요 특징 
#### 선언적 데이터 요청
- 클라이언트가 스키마를 통해 원하는 데이터 구조 정의
- 필요한 필드만 선택적으로 요청 가능
- Over/Under-fetching 문제 해결

#### 강력한 타입 시스템
- 스키마 기반의 타입 시스템 제공
- 런타임 이전에 타입 검증 가능
- API 문서 자동 생성

### REST와의 비교

#### GraphQL 장점
- 필요한 데이터만 정확히 요청 (Over-fetching 방지)
- 여러 리소스를 단일 요청으로 처리 (Under-fetching 방지)
- 강력한 타입 시스템으로 안정성 확보
- 실시간 업데이트(Subscriptions) 지원
- API 버저닝 불필요

#### GraphQL 단점
- 학습 곡선이 높음
- HTTP 캐싱 구현이 복잡
	- 요청마다 다른 쿼리문 사용으로 캐시 키 생성 어려움
- 파일 업로드 처리가 번거로움
- 단순한 API에서는 오버엔지니어링 될 수 있음

#### REST 장점
- 단순하고 직관적인 구조
- HTTP 캐싱 용이
- 브라우저에서 바로 테스트 가능
- 파일 전송 처리 용이
- 더 폭넓은 생태계

#### REST 단점
- Over-fetching / Under-fetching 문제
	- 클라이언트가 실제로 필요한 것보다 더 많은 데이터를 서버로부터 받는 상황
	- 예시: 사용자 프로필에서 이름만 필요한데, API가 사용자의 모든 정보(이메일, 주소, 전화번호 등)를 반환
- 엔드포인트 관리 복잡성
- 필요한 데이터만 선택적 요청 어려움
- API 버저닝 필요

### 사용 케이스
#### GraphQL 적합
- 복잡한 데이터 요구사항
- 다양한 프론트엔드 클라이언트
- 빈번한 API 변경
- 모바일 앱 (데이터 효율성 중요)

#### REST 적합
- 단순한 CRUD 작업
- 캐싱이 중요한 경우
- 파일 업로드가 많은 경우
- 공개 API 제공


### GraphQL의 HTTP 캐싱 한계

#### HTTP 캐싱의 작동 방식
- 브라우저는 URL, HTTP 메서드, 헤더를 기반으로 응답을 캐싱
- REST API의 경우:
  - GET /users/1 -> 특정 유저 데이터 캐시
  - GET /posts/1 -> 특정 포스트 데이터 캐시
  - 각 엔드포인트별로 독립적인 캐싱 가능

#### GraphQL의 캐싱 문제
##### 1. 단일 엔드포인트
- 모든 요청이 POST /graphql로 이루어짐
- URL 기반 캐싱 활용 불가
- 매 요청마다 브라우저가 새로운 요청으로 인식

##### 2. 요청 본문 차이
- 같은 데이터를 요청하더라도 쿼리문이 다르면 다른 요청으로 취급
- 예시
  ```graphql
  // 두 쿼리는 같은 데이터를 요청하지만 다른 형태
  query { user(id: "1") { name } }
  query { user(id: "1") { name age } }